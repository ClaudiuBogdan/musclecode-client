import {
  ChatMessage,
  ChatSession,
  ContentElement,
  ContextReference,
} from "../types";

/**
 * State structure for the chat store
 */
export interface ChatStoreState {
  /**
   * Dictionary of chat sessions indexed by their IDs
   */
  sessions: Record<string, ChatSession>;

  /**
   * ID of the currently active chat session
   */
  currentSessionId: string | null;

  /**
   * Flag indicating if the store is performing a major initial load
   */
  isLoading: boolean;

  /**
   * Any critical global error related to the store's operation
   */
  error: Error | null;

  /** Optional: Track loading status per session for finer-grained UI feedback */
  sessionLoadingStatus: Record<string, boolean>;
}

/**
 * Actions available on the chat store
 */
export interface ChatStoreActions {
  /**
   * Hydrates state from local storage and triggers initial sync with backend.
   * Should be called once when the app loads.
   */
  loadInitialState: () => Promise<void>;

  /**
   * Creates a new chat session via the backend.
   * @param title Optional title for the session
   * @param context Optional initial context references
   * @returns The created session
   */
  createSession: (
    title?: string,
    context?: ContextReference[]
  ) => Promise<ChatSession>;

  /**
   * Switches the active session. May trigger message loading if needed.
   * @param sessionId ID of the session to switch to
   */
  switchSession: (sessionId: string) => void;

  /**
   * Deletes a chat session optimistically, then confirms with backend.
   * @param sessionId ID of the session to delete
   */
  deleteSession: (sessionId: string) => Promise<void>;

  /**
   * Adds a user message optimistically, sends it to the backend,
   * and updates the message status/ID upon response.
   * @param sessionId ID of the session to add the message to
   * @param messageData Content and other non-generated fields for the user message.
   */
  addMessage: (
    sessionId: string,
    // Ensuring content matches ContentElement[] is important here
    messageData: { content: ContentElement[] } & Omit<
      ChatMessage,
      "id" | "createdAt" | "role" | "status" | "content" // Omit fields generated by the store/backend
    >
  ) => Promise<void>;

  /**
   * Attaches context to a session locally.
   * Note: This implementation doesn't automatically sync this change to the backend.
   * Consider adding a dedicated API call if session-level context needs backend persistence.
   * @param sessionId ID of the session to attach context to
   * @param context Context reference to attach
   */
  attachContext: (sessionId: string, context: ContextReference) => void;

  /**
   * Removes a context reference from a session locally by its ID.
   * Similar to attachContext, consider backend sync if needed.
   * @param sessionId ID of the session
   * @param contextId ID of the context reference to remove
   */
  removeContext: (sessionId: string, contextId: string) => void;

  /**
   * Clears the global error state
   */
  clearError: () => void;

  // --- Internal Helpers ---

  /**
   * Internal helper to add a new message or update an existing one by ID.
   * Used for optimistic updates and processing backend responses.
   * @param sessionId ID of the session
   * @param message Complete message data
   * @param replaceTempId Optional: The temporary ID to look for when replacing with a final message.
   */
  _addOrUpdateMessage: (
    sessionId: string,
    message: ChatMessage,
    replaceTempId?: string
  ) => void;

  /**
   * Internal helper to fetch messages for a session and merge them intelligently.
   * @param sessionId ID of the session to sync
   * @param force If true, bypasses checks and forces a full sync.
   */
  _syncSessionMessagesWithBackend: (
    sessionId: string,
    force?: boolean
  ) => Promise<void>;
}

/**
 * Complete chat store type combining state and actions
 */
export type ChatStore = ChatStoreState & ChatStoreActions;
